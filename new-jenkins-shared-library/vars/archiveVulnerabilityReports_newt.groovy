import java.text.SimpleDateFormat
import hudson.model.Actionable
import hudson.model.Result

def call(body) {
    def config = [:]
    body.resolveStrategy = Closure.DELEGATE_FIRST
    body.delegate = config
    body()

    def AGENT = config.AGENT ?: ''
    def REPORTS_PATTERN = config.REPORTS_PATTERN ?: 'vulnerability_count_*.txt'

    try {
        podTemplate(
            nodeSelector: 'cloud.google.com/gke-nodepool=spot-node-pool-1',
            containers: [containerTemplate(name: 'jnlp', image: 'asia.gcr.io/common-infra-services/jenkins-agent-updated:mss-cli')],
            volumes: [hostPathVolume(hostPath: '/var/run/docker.sock', mountPath: '/var/run/docker.sock'),
                      persistentVolumeClaim(claimName: 'jenkinsagentpvc', mountPath: '/home/jenkins/agent', readOnly: false)
            ]) {
            node(POD_LABEL) {
                
                stage('Archive Vulnerability Reports') {
                    container('jnlp') {
                        echo "=== Starting Report Collection and Archiving ==="
                        
                        // Unstash all reports from previous stages
                        def stashedReports = ['snyk-reports', 'snyk-vulnerability-summary', 'checkov-reports', 'prisma-reports', 'checkmarx-reports']
                        def retrievedReports = []
                        
                        stashedReports.each { reportName ->
                            try {
                                unstash reportName
                                retrievedReports << reportName
                                echo "✓ Successfully retrieved ${reportName}"
                            } catch (Exception e) {
                                echo "⚠ Could not unstash ${reportName}: ${e.message}"
                            }
                        }
                        
                        echo "Retrieved ${retrievedReports.size()} stash(es): ${retrievedReports.join(', ')}"

                        // Create security_reports directory and copy files for zip creation only
                        sh """
                            mkdir -p security_reports
                            
                            # Snyk reports
                            cp -v Snyk_Report.json security_reports/ 2>/dev/null || echo "Snyk_Report.json not found"
                            cp -v Snyk_Report.html security_reports/ 2>/dev/null || echo "Snyk_Report.html not found"
                            cp -v Snyk_Report.pdf security_reports/ 2>/dev/null || echo "Snyk_Report.pdf not found"
                            
                            # Checkov reports
                            cp -v checkov_report.json security_reports/ 2>/dev/null || echo "checkov_report.json not found"
                            cp -v results_json.json security_reports/ 2>/dev/null || echo "results_json.json not found"
                            cp -v results_junitxml.xml security_reports/ 2>/dev/null || echo "results_junitxml.xml not found"
                            
                            # Prisma reports
                            cp -v prisma_report.json security_reports/ 2>/dev/null || echo "prisma_report.json not found"
                            cp -v image_scan_results.json security_reports/ 2>/dev/null || echo "image_scan_results.json not found"
                            
                            # Checkmarx reports
                            cp -v checkmarx_report.csv security_reports/ 2>/dev/null || echo "checkmarx_report.csv not found"
                            cp -v checkmarx_report.pdf security_reports/ 2>/dev/null || echo "checkmarx_report.pdf not found"
                            
                            # Vulnerability count summaries
                            cp -v vulnerability_count_*.txt security_reports/ 2>/dev/null || echo "Vulnerability count files not found"
                            
                            echo "Files in security_reports directory:"
                            ls -lh security_reports/ || echo "Directory is empty"
                        """

                        // Check if any files were collected
                        def filesCollected = sh(
                            script: "ls -A security_reports/ | wc -l",
                            returnStdout: true
                        ).trim().toInteger()
                        
                        if (filesCollected > 0) {
                            echo "✓ Collected ${filesCollected} file(s) for zip creation"
                            
                            // Create combined zip archive but don't archive it to Jenkins
                            try {
                                zip zipFile: 'all_security_reports.zip', archive: false, dir: 'security_reports'
                                echo "✓ Created all_security_reports.zip (not archived to Jenkins dashboard)"
                            } catch (Exception e) {
                                echo "⚠ Failed to create zip archive: ${e.message}"
                            }
                        } else {
                            echo "⚠ No security report files were collected"
                        }

                        // Generate combined summary report
                        try {
                            generateCombinedReport()
                            echo "✓ Generated combined security report"
                        } catch (Exception e) {
                            echo "⚠ Failed to generate combined report: ${e.message}"
                        }
                        
                        // Archive vulnerability count reports matching the pattern
                        try {
                            archiveArtifacts artifacts: REPORTS_PATTERN, allowEmptyArchive: true
                            echo "✓ Archived vulnerability count reports"
                        } catch (Exception e) {
                            echo "⚠ Failed to archive vulnerability count reports: ${e.message}"
                        }
                        
                        echo "=== Report archiving process completed ==="
                    }
                }
            }
        }
    } catch (Exception err) {
        echo "⚠ Error in Archive Vulnerability Reports stage: ${err.message}"
        echo "Pipeline will continue despite archiving errors"
        // Don't change build result - let it continue
    }
}

def generateCombinedReport() {
    try {
        def dateTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())
        def combinedReport = """SECURITY SCAN SUMMARY REPORT
========================================================================
Generated: ${dateTime}
Build: ${env.JOB_NAME} #${env.BUILD_NUMBER}
Pipeline: ${env.BUILD_URL}
========================================================================
"""

        def reportsFound = 0

        // Add Snyk summary if available
        if (fileExists('vulnerability_count_snyk.txt')) {
            combinedReport += "\n" + readFile('vulnerability_count_snyk.txt') + "\n"
            combinedReport += "------------------------------------------------------------------------\n"
            reportsFound++
            echo "✓ Added Snyk report to combined summary"
        } else {
            echo "⚠ Snyk vulnerability report not found"
        }

        // Add Checkov summary if available
        if (fileExists('vulnerability_count_checkov.txt')) {
            combinedReport += "\n" + readFile('vulnerability_count_checkov.txt') + "\n"
            combinedReport += "------------------------------------------------------------------------\n"
            reportsFound++
            echo "✓ Added Checkov report to combined summary"
        } else {
            echo "⚠ Checkov vulnerability report not found"
        }

        // Add Prisma summary if available
        if (fileExists('vulnerability_count_prisma.txt')) {
            combinedReport += "\n" + readFile('vulnerability_count_prisma.txt') + "\n"
            combinedReport += "------------------------------------------------------------------------\n"
            reportsFound++
            echo "✓ Added Prisma report to combined summary"
        } else {
            echo "⚠ Prisma vulnerability report not found"
        }

        // Add Checkmarx summary if available
        if (fileExists('vulnerability_count_sast.txt')) {
            combinedReport += "\n" + readFile('vulnerability_count_sast.txt') + "\n"
            combinedReport += "------------------------------------------------------------------------\n"
            reportsFound++
            echo "✓ Added Checkmarx report to combined summary"
        } else {
            echo "⚠ Checkmarx vulnerability report not found"
        }

        if (reportsFound == 0) {
            combinedReport += "\n⚠ No vulnerability reports were found.\n"
            echo "⚠ No vulnerability reports were found for combined summary"
        } else {
            echo "✓ Combined ${reportsFound} report(s)"
        }

        // Calculate overall severity summary
        def overallSummary = calculateOverallSeverity()
        if (overallSummary) {
            combinedReport += "\n${overallSummary}\n"
        }

        // Add overall status
        combinedReport += "\nOVERALL BUILD STATUS: ${currentBuild.result ?: 'SUCCESS'}\n"
        combinedReport += "========================================================================\n"

        // Write combined report
        writeFile file: 'combined_security_report.txt', text: combinedReport
        archiveArtifacts artifacts: 'combined_security_report.txt', allowEmptyArchive: true
        echo "Combined Security Report:\n${combinedReport}"
        
    } catch (Exception e) {
        echo "⚠ Error generating combined report: ${e.message}"
        // Don't change build result - just log the error
    }
}

def calculateOverallSeverity() {
    try {
        def totalHigh = 0
        def totalMedium = 0
        def totalLow = 0
        def totalInfo = 0
        def scansCompleted = []
        
        // Parse Snyk report
        if (fileExists('vulnerability_count_snyk.txt')) {
            def snykContent = readFile('vulnerability_count_snyk.txt')
            def highMatch = snykContent =~ /High:\s*(\d+)/
            def mediumMatch = snykContent =~ /Medium:\s*(\d+)/
            def lowMatch = snykContent =~ /Low:\s*(\d+)/
            
            if (highMatch) totalHigh += highMatch[0][1].toInteger()
            if (mediumMatch) totalMedium += mediumMatch[0][1].toInteger()
            if (lowMatch) totalLow += lowMatch[0][1].toInteger()
            scansCompleted << 'Snyk'
        }
        
        // Parse Checkov report
        if (fileExists('vulnerability_count_checkov.txt')) {
            def checkovContent = readFile('vulnerability_count_checkov.txt')
            def criticalMatch = checkovContent =~ /Critical:\s*(\d+)/
            def highMatch = checkovContent =~ /High:\s*(\d+)/
            def mediumMatch = checkovContent =~ /Medium:\s*(\d+)/
            def lowMatch = checkovContent =~ /Low:\s*(\d+)/
            
            if (criticalMatch) totalHigh += criticalMatch[0][1].toInteger()
            if (highMatch) totalHigh += highMatch[0][1].toInteger()
            if (mediumMatch) totalMedium += mediumMatch[0][1].toInteger()
            if (lowMatch) totalLow += lowMatch[0][1].toInteger()
            scansCompleted << 'Checkov'
        }
        
        // Parse Prisma report
        if (fileExists('vulnerability_count_prisma.txt')) {
            def prismaContent = readFile('vulnerability_count_prisma.txt')
            def criticalMatch = prismaContent =~ /Critical:\s*(\d+)/
            def highMatch = prismaContent =~ /High:\s*(\d+)/
            def mediumMatch = prismaContent =~ /Medium:\s*(\d+)/
            def lowMatch = prismaContent =~ /Low:\s*(\d+)/
            
            if (criticalMatch) totalHigh += criticalMatch[0][1].toInteger()
            if (highMatch) totalHigh += highMatch[0][1].toInteger()
            if (mediumMatch) totalMedium += mediumMatch[0][1].toInteger()
            if (lowMatch) totalLow += lowMatch[0][1].toInteger()
            scansCompleted << 'Prisma'
        }
        
        // Parse Checkmarx report
        if (fileExists('vulnerability_count_sast.txt')) {
            def checkmarxContent = readFile('vulnerability_count_sast.txt')
            def highMatch = checkmarxContent =~ /High:\s*(\d+)/
            def mediumMatch = checkmarxContent =~ /Medium:\s*(\d+)/
            def lowMatch = checkmarxContent =~ /Low:\s*(\d+)/
            def infoMatch = checkmarxContent =~ /Information:\s*(\d+)/
            
            if (highMatch) totalHigh += highMatch[0][1].toInteger()
            if (mediumMatch) totalMedium += mediumMatch[0][1].toInteger()
            if (lowMatch) totalLow += lowMatch[0][1].toInteger()
            if (infoMatch) totalInfo += infoMatch[0][1].toInteger()
            scansCompleted << 'Checkmarx'
        }
        
        if (scansCompleted.size() == 0) {
            return null
        }
        
        def total = totalHigh + totalMedium + totalLow + totalInfo
        
        def summary = """OVERALL VULNERABILITY SUMMARY (Across ${scansCompleted.size()} Tool${scansCompleted.size() > 1 ? 's' : ''})
Tools: ${scansCompleted.join(', ')}

COMBINED COUNTS:
  Critical/High: ${totalHigh}
  Medium:        ${totalMedium}
  Low:           ${totalLow}
  Info:          ${totalInfo}
  ─────────────────
  Total:         ${total}

RISK ASSESSMENT: ${getRiskLevel(totalHigh, totalMedium)}
"""
        return summary
        
    } catch (Exception e) {
        echo "⚠ Error calculating overall severity: ${e.message}"
        return null
    }
}

def getRiskLevel(high, medium) {
    if (high >= 10) return "CRITICAL - Immediate action required"
    if (high >= 5) return "HIGH - Urgent attention needed"
    if (high >= 1) return "ELEVATED - Review and remediate"
    if (medium >= 10) return "MODERATE - Plan remediation"
    return "LOW - Acceptable risk level"
}